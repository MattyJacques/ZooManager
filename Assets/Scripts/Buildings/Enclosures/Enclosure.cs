// Title        : Enclosure.cs
// Purpose      : This class controls both the GUI and functionality for the enclosure
// Author       : Eivind Andreassen
// Date         : 20/12/2016

using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Linq;

//TODO: separate the GUI into it's own class
public class Enclosure : MonoBehaviour
{
  private int _maxNameLength = 20;
  private int _minNameLength = 3;
  
  /*
  //TODO: Implement State to track what state the enclosure currently is in
  //Commented out for now to suppress warnings generated by unused variables
  private enum State
  {
    Idle,
    DisplayingMenu,
  };
  
  private State _state = State.Idle;
  */

  private string _name;
  private GameObject _canvas;
  private EnclosureGUIController _enclosureGUIController;

  private List<EnclosureInteriorItem> _interiorItems = new List<EnclosureInteriorItem>();

  public void Start()
  { //Initialization

    //Check that we have a general collider
    if (!GetComponent<BoxCollider>() && !GetComponent<MeshCollider>())
    {
      Debug.LogError("Enclosure " + name + " at " + transform.position.ToString() + " has no collider!");
    }

    //Get the GUI controller
    _enclosureGUIController = GetComponent<EnclosureGUIController> ();

  } //Start()

  public void OnClick()
  { //Is called when the player clicks on the Enclosure NOTE: replace with onclick?
    //Instantiates and initializes the GUI that allows for player interaction with the enclosure

    if (_enclosureGUIController._state == EnclosureGUIController.UIState.Uninitialized)
    {
      _enclosureGUIController.Initialize ();
    }
    else if (_enclosureGUIController._state == EnclosureGUIController.UIState.Hidden)
    {
      _enclosureGUIController.ShowCanvas ();
    }
    else
    { //We might not want to hide the GUI on aditional clicks.
      _enclosureGUIController.HideCanvas ();
    }
  } //OnClick()

  public Transform GetClosestInteriorItem(Vector3 fromPosition, EnclosureInteriorItem.InteriorItemType itemType)
  { //Returns the closest Transform of itemType
    EnclosureInteriorItem interiorItem = _interiorItems.Where(x => x.type == itemType)
        .OrderBy(x => Vector3.Distance(fromPosition, x.transform.position))
        .FirstOrDefault();

    if (interiorItem == null)
    {
      Debug.LogWarning("Tried getting the closest interiorItem transform of type " + itemType.ToString()
          + ", from the position " + fromPosition.ToString()
          + ", but enclosure \"" + _name + "\" contains no such type of interiorItem.");
    }
    return interiorItem.transform;
  } //GetClosest()

  public void RegisterNewInteriorItem(GameObject gameObject, EnclosureInteriorItem.InteriorItemType itemType)
  { // Register a new interior object into a enclosure

    EnclosureInteriorItem newItem = new EnclosureInteriorItem(gameObject, itemType);
    _interiorItems.Add(newItem);

    Debug.Log("Added new interiorItem " + gameObject.name
        + ", of type " + itemType.ToString()
        + ", to enclosure " + _name
        + ", at position " + gameObject.transform.position.ToString()
        + ".");

  } //RegisterNewInteriorItem()

  public bool Rename(string name)
  { //Renames the enclosure

    if (name.Length > _minNameLength || name.Length < _maxNameLength)
    {
      _name = name;
      if (_canvas != null)
      {
        _canvas.transform.FindChild("Text_EnclosureName").GetComponent<Text>().text = _name;
      }
      return true;
    }
    else
    {
      return false;
    }

  } //Rename()

  private void DeleteThisEnclosure()
  { //Deletes this enclosure and all attached objects

    if (_canvas != null)
    {
      Destroy(_canvas);
    }

    Destroy(gameObject);

  } //DeleteThisEnclosure

} // Enclosure
